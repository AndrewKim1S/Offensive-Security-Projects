###############################################################################
#                      Windows Hacking & PE file format                       #
###############################################################################


                        Windows Foundational Concepts 
_______________________________________________________________________________
Windows Architecture Overview

															+--------------+
															| Applications |
															+--------------+
																		 ↓↑
								+-----------+   +---------+
								| User-mode | → | Windows |
								|  drivers  | ← |   API   |
								+-----------+   +---------+
	User mode           Ʌ |           Ʌ |
	--------------------|-|-----------|-|----------
	Kernel mode         | v           | v
									+---------+   +---------+
									| Kernel  | → | Windows |
									| drivers | ← |  Kernel |
									+---------+   +---------+
											 ↑↓            ↑↓
								+----------------------------+
								| Hardware abstraction layer |
								+----------------------------+
															↑↓       
												 +----------+
												 | Hardware |
												 +----------+

	Applications:  These are the software and programs that a user runs

	Windows API:   What apps rely on in order to function
	
	Drivers:       Control various devices on the system & provide an abstraction
	               layer between the devices and programs
	
	Hardware       Provides an interface that device drivers can use to 
	abstration     communicate with underlying system hardware 
	layer: 


Objects and Handles
	Objects are instances of a certain type of resource (file, process, 
	security token)
	They are simply data structures, typically stored in kernel memory

	A process uses a unique identifier known as handle to access an object
	Each process may have multiple handles for various objects 
	Handles are managed in a process's handle table, which contain pointers to 
	the objects in kernel memory

	        +---------+
	        | Process |
	user    +---------+
	    		     |
	-------------+-------------------------------------------------------
  kernel       |
	             v 
	+-------------------------+         +-----------------------+
	|  Process handle table   |         | Object manager header |
	+------------+------------+         +-----------------------+
	| Handle 0x1 | Object ptr |-------> | Object data structure |
	+------------+------------+         +-----------------------+
  | Handle 0x4 | Object ptr |         
	+------------+------------+         
  | Handle 0x8 | Object ptr |
	+------------+------------+
  | Handle ... | Object ptr |
	+------------+------------+

	Object Manager is responsible for tracking all Windows objects, sharing among
	processes, and protecting from unauthorized access


Windows API
Windows Native API: lower level API 
	- Windows Native API functions have prefix Nt or Zw
	- Windows API -> Windows Native API -> kernel 

_______________________________________________________________________________
Process Internals 
	- processes are represented in kernel addr space as objects called EPROCESS structs
	- Each process has its own EPROCESS structure that contains ptrs to elements
		like list of handles the process has open, Process Environment Block (PEB)
		which is a struct that contains vital info about the process
	- EPROCESS structs consist of a doubly linked list 

	Thread Environment Block 
			typedef struct _TEB {
				PVOID Reserved1[12];
				PPEB  ProcessEnvironmentBlock;
				PVOID Reserved2[399];
				BYTE  Reserved3[1952];
				PVOID TlsSlots[64];
				BYTE  Reserved4[8];
				PVOID Reserved5[26];
				PVOID ReservedForOle;
				PVOID Reserved6[4];
				PVOID TlsExpansionSlots;
			} TEB, *PTEB;

	Process Environment Blocks
	https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data?redirectedfrom=MSDN

		- The PEB memory struct contains info about a running process that the kernel
			needs to communicate with that process & info for icp 
		- Each running process has its own PEB that's stored in user-mode addr space 
			inside that process memory 
		- Exists in User address space & available for every process at a fixed addr
			in memory. 

			typedef struct _PEB {
				BYTE                          Reserved1[2];
				BYTE                          BeingDebugged;
				BYTE                          Reserved2[1];
				PVOID                         Reserved3[2];
				PPEB_LDR_DATA                 Ldr;
				PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
				PVOID                         Reserved4[3];
				PVOID                         AtlThunkSListPtr;
				PVOID                         Reserved5;
				ULONG                         Reserved6;
				PVOID                         Reserved7;
				ULONG                         Reserved8;
				ULONG                         AtlThunkSListPtr32;
				PVOID                         Reserved9[45];
				BYTE                          Reserved10[96];
				PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
				BYTE                          Reserved11[128];
				PVOID                         Reserved12[1];
				ULONG                         SessionId;
			} PEB, *PPEB;

			typedef struct _PEB_LDR_DATA {
				BYTE       Reserved1[8];
				PVOID      Reserved2[3];
				LIST_ENTRY InMemoryOrderModuleList;
			} PEB_LDR_DATA, *PPEB_LDR_DATA;

			typedef struct _LIST_ENTRY {
				struct _LIST_ENTRY *Flink;
				struct _LIST_ENTRY *Blink;
			} LIST_ENTRY, *PLIST_ENTRY, PRLIST_ENTRY;


		- From the PPEB_LDR_DATA Ldr, the LIST_ENTRY InMemoryOrderModuleList is a 
			doubly linked list that contains the loaded modules for the process 
			Each item in the list is a ptr to an LDR_DATA_TABLE_ENTRY struct. This 
			can give us the specific dlls.
			- The image exe <-> Ntdll.dll <-> kernerl32.dll 
			- Can be used to access kernel32.dll to access functions and call any 
				Windows API function

			typedef struct _LDR_DATA_TABLE_ENTRY {
					PVOID Reserved1[2];
					LIST_ENTRY InMemoryOrderLinks;
					PVOID Reserved2[2];
					PVOID DllBase;
					PVOID EntryPoint;
					PVOID Reserved3;
					UNICODE_STRING FullDllName;
					BYTE Reserved4[8];
					PVOID Reserved5[3];
					union {
							ULONG CheckSum;
							PVOID Reserved6;
					};
					ULONG TimeDateStamp;
			} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

	* PVOID is 4 bytes in 32 bit, 8 bytes in 64 bit
	* Use WinDBG to confirm actual locations
	* fs and gs segmented registers

_______________________________________________________________________________
PE File Format
https://tech-zealots.com/malware-analysis/pe-portable-executable-structure-malware-analysis-part-2/

	DOS Header
		- 64 byte long struct that exists at the start of the PE file

		typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
			WORD   e_magic;                     // Magic number
			WORD   e_cblp;                      // Bytes on last page of file
			WORD   e_cp;                        // Pages in file
			WORD   e_crlc;                      // Relocations
			WORD   e_cparhdr;                   // Size of header in paragraphs
			WORD   e_minalloc;                  // Minimum extra paragraphs needed
			WORD   e_maxalloc;                  // Maximum extra paragraphs needed
			WORD   e_ss;                        // Initial (relative) SS value
			WORD   e_sp;                        // Initial SP value
			WORD   e_csum;                      // Checksum
			WORD   e_ip;                        // Initial IP value
			WORD   e_cs;                        // Initial (relative) CS value
			WORD   e_lfarlc;                    // File address of relocation table
			WORD   e_ovno;                      // Overlay number
			WORD   e_res[4];                    // Reserved words
			WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
			WORD   e_oeminfo;                   // OEM information; e_oemid specific
			WORD   e_res2[10];                  // Reserved words
			LONG   e_lfanew;                    // File address of new exe header     <---- location of PE header 
		} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

	DOS Stub
		- is an MS-DOS program that prints error message saying that exe is not 
			compatible with DOS then exits. Happens when the progr is loaded in MS-DOS

	PE Header (Image_NT_Headers)
		- Constains PE signature, FileHeader (number of sections code & data), 
			machine type(x86, ARM), and exe or dll.

			typedef struct _IMAGE_NT_HEADERS {
					DWORD Signature;
					IMAGE_FILE_HEADER FileHeader;			<-- always 20 bytes
					IMAGE_OPTIONAL_HEADER32 OptionalHeader;
			} IMAGE_NT_HEADERS32,

		- Optional Header has AddressOfEntryPoint, ImageBase, DataDirectory 
			(info such as imported and exported functions)

			typedef struct _IMAGE_OPTIONAL_HEADER {
					DWORD   AddressOfEntryPoint;
					DWORD   BaseOfCode;
					DWORD   BaseOfData;
					...

					IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];   (also 0x78 from PE header)
			} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

		- At the end of OptionalHeader struct there are IMAGE_DATA_DIRECTORY structures (16)
		- To get to certain directory follow the VirtualAddress field 
			typedef struct _IMAGE_DATA_DIRECTORY {
				DWORD VirtualAddress;
				DWORD Size;
			} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

			#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
			#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
			#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
			#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
			#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
			#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
			#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
			#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
			#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
			#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
			#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
			#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
			#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
			#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
			#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor

		- Example of Image_Directory (_IMAGE_EXPORT_DIRECTORY)
		struct IMAGE_EXPORT_DIRECTORY {
				pub Characteristics: u32,
				pub TimeDateStamp: u32,
				pub MajorVersion: u16,
				pub MinorVersion: u16,
				pub Name: u32,
				pub Base: u32,
				pub NumberOfFunctions: u32,
				pub NumberOfNames: u32,
				pub AddressOfFunctions: u32,    <-- Address of an array of ptrs to functions
				pub AddressOfNames: u32,        <-- Address of an array of ptr to function names
				pub AddressOfNameOrdinals: u32, <-- Address of an array of ordinals 
					(representing the offsets of each function in the AddressOfFunctions array)
		}

	Sections
		- section header which is metadata related to each of the file's sections
		- .text, .rdata, .bss, .data, .rsrc, .idata (imports), .edata (exports)
		- .idata contains info about functions that the PE file will import at runtime
			Once PE file is executed, the program will load the libs & funcs referenced
			here into memory and build its import addr table (IAT) which maps the 
			imported Windows API functions to their addresses in memory
		- .edata contains into about the functions that the PE file exports to other
			programs exports have their own table export addr table
		- In practice .edata & .idata sections are often contained in .rdata section

_______________________________________________________________________________ 
	Windows PE Loading Process
		1. Windows creates a new EPROCESS data struct for application & assigns new pid
		2. Windows initializes the virtual memory for the process, creates the PEB structure,
			 and loads two libs ntdll.dll & kernel32.dll. Initializes the PE loader
		3. The PE loader parses the DOS, PE, & optional headers of the PE file to 
			 gather info required to successfully execute the file
		4. The PE loader parses the section header to prepare for mapping these sections into 
			 memory. The loader maps each section into virtual memory within the new process
		5. The PE loader loads all libs referenced in the imports & resolves all addrs for
			 the functions required. All addrs are then stored in the IAT inside the process
		6. A new thread is created inside the current process & the loader executes 
			 the first bytes of code in the executable (usually .text section)

	   PE file          Virtual Memory
	+------------+      +------------+
	| DOS header |      | DOS header |
	+------------+      +------------+
	| PE header  |      |    ...     |
	+------------+      +------------+
	|    ...     |      | PE header  |
	+------------+      +------------+
	|   .text    |      |    ...     |
	+------------+      +------------+
	|   .data    |      |   .text    | 
	+------------+      +------------+
	|   .rdata   |      |    ...     |
	+------------+      +------------+
	|    ...     |      |   .data    |
	+------------+      +------------+
	                    |    ...     |
											+------------+
											|   .rdata   |
											+------------+
											|    ...     |
											+------------+

	- Each section in the PE file is individually mapped into memory, but it appears
		expanded in virtual memory as there are often regions of memory between each
		section

